The goal of this library is to provide a C++ J\+S\+ON interface that\textquotesingle{}s simple to use and doesn\textquotesingle{}t require any dependencies. This library provides all necessary operations required for working with J\+S\+ON documents (see \href{#expamles_section}{\tt examples}).

{\bfseries Note\+:} The library only works with C++ 11 and newer.


\begin{DoxyItemize}
\item \href{#cpp_representation_section}{\tt C++ Representation of J\+S\+ON}
\item \href{#integration_section}{\tt Integration}
\item \href{#doc_section}{\tt Documentation}
\item \href{#tests_section}{\tt Tests}
\item \href{#expamles_section}{\tt Examples}
\begin{DoxyItemize}
\item \href{#parsing_json_string_section}{\tt Parsing a J\+S\+ON string}
\item \href{#opening_changing_section}{\tt Opening, changing and saving a J\+S\+ON file}
\item \href{#working_with_simple_section}{\tt Working with simple json\+\_\+variant values}
\item \href{#working_with_json_array_section}{\tt Working with json\+\_\+array}
\item \href{#working_with_json_object_section}{\tt Working with json\+\_\+object}
\item \href{#typecast_exceptions_section}{\tt Typecast exceptions}
\begin{DoxyItemize}
\item \href{#handling_typecast_expception_section}{\tt Handling typecast a exception}
\item \href{#avoid_typecast_exception_section}{\tt Avoid typecast a exception}
\end{DoxyItemize}
\item \href{#json_and_string_escapes_section}{\tt J\+S\+ON and string escapes}
\end{DoxyItemize}
\item \href{#customization_section}{\tt Customization}
\item \href{#troubleshooting_section}{\tt Troubleshooting}
\end{DoxyItemize}

\subsubsection*{\label{_cpp_representation_section}%
C++ Representation of J\+S\+ON}

All possible J\+S\+ON values are represenented in the class {\ttfamily json\+\_\+variant}. The datatypes are\+:
\begin{DoxyItemize}
\item int value\+: {\ttfamily json\+\_\+int} (typedef of {\ttfamily std\+::int64\+\_\+t})
\item double value\+: {\ttfamily double}
\item bool value\+: {\ttfamily bool}
\item string value\+: {\ttfamily std\+::string}
\item array value\+: {\ttfamily json\+\_\+array} (typedef of {\ttfamily std\+::vector$<$json\+\_\+variant$>$})
\item object value\+: {\ttfamily json\+\_\+object} (typedef of {\ttfamily std\+::map$<$std\+::string, json\+\_\+variant$>$})
\end{DoxyItemize}

\subsubsection*{\label{_integration_section}%
Integration}

Since the library consists only of the two files \href{https://github.com/n0dex/cppjsonlib/blob/master/json_library.h}{\tt json\+\_\+library.\+h} and \href{https://github.com/n0dex/cppjsonlib/blob/master/json_library.cpp}{\tt json\+\_\+library.\+cpp} you can just download them and add them into your project. To use the library, you should use {\ttfamily \#include \char`\"{}json\+\_\+library.\+h\char`\"{}} and define the namespace {\ttfamily using namespace json;} (recommended).

If you prefer to add the files seperated by classes you can download the \href{https://github.com/n0dex/cppjsonlib/tree/master/json_library_source}{\tt json\+\_\+library} directory and include the directory into your project. To use the library in this case, you should use {\ttfamily \#include \char`\"{}json\+\_\+library\+\_\+source/json\+\_\+library.\+h\char`\"{}}.

\subsubsection*{\label{_doc_section}%
Documentation}

The library is documented with doxygen. The documentation can be found \href{https://github.com/n0dex/cppjsonlib/tree/master/json_library_documentation}{\tt here}. ~\newline
To use the documentation open \href{https://github.com/n0dex/cppjsonlib/blob/master/json_library_documentation/html/index.html}{\tt html/index.\+html} in a browser.

\subsubsection*{\label{_tests_section}%
Tests}

The library was thoroughly tested. The test cases are written with the Qt Test Library and can be found \href{https://github.com/n0dex/cppjsonlib/tree/master/json_library_tests}{\tt here}.

\subsubsection*{\label{_expamles_section}%
Examples}

The following examples will show how to work with the library.

\paragraph*{\label{_parsing_json_string_section}%
Parsing a J\+S\+ON string}


\begin{DoxyCode}
\textcolor{comment}{// include library}
\textcolor{preprocessor}{#include "json\_library.h"}

\textcolor{comment}{// for convenience}
\textcolor{keyword}{using namespace }json;

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{char} *[]) \{

    \textcolor{comment}{// initializing a string}
    std::string string\_value = \textcolor{stringliteral}{"\{ }
\textcolor{stringliteral}{        \(\backslash\)"name\(\backslash\)": \(\backslash\)"user\(\backslash\)", }
\textcolor{stringliteral}{        \(\backslash\)"age\(\backslash\)": 22, }
\textcolor{stringliteral}{        \(\backslash\)"favourite\_values\(\backslash\)": [ 2, null, false, \{\}] }
\textcolor{stringliteral}{    \}"};

    \textcolor{comment}{// initializing a string with an easier writing - content same as above}
    string\_value = R\textcolor{stringliteral}{"(\{}
\textcolor{stringliteral}{        "name": "user",}
\textcolor{stringliteral}{        "age": 22,}
\textcolor{stringliteral}{        "favourite\_values": [2, null, false, \{\}]}
\textcolor{stringliteral}{    \})";}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{    }\textcolor{comment}{// parse string}
    json\_variant json = json\_variant::parse(string\_value);

    \textcolor{comment}{// print json into console}

    \textcolor{comment}{// prints the json with default indent of 4}
    std::cout << json << std::endl;
    \textcolor{comment}{// prints the json with indent of 2    }
    std::cout << json.dump(2) << std::endl;     
    \textcolor{comment}{// prints the json no indent and no new lines: }
    \textcolor{comment}{// "\{"age":22,"favourite\_values":[2,null,false,\{\}],"name":"user"\}"}
    std::cout << json.dump(0) << std::endl;     

    \textcolor{comment}{// prints "1" because the source string is valid json and was successfully parsed}
    std::cout << json.is\_valid\_json() << std::endl; 
    \textcolor{comment}{// prints "0" because the root is an object and not an array}
    std::cout << json.is\_array() << std::endl;     

    \textcolor{keywordflow}{if} (json.is\_object()) \{
        \textcolor{comment}{// prints "user"}
        std::cout << json.to\_object()[\textcolor{stringliteral}{"name"}].to\_string() << std::endl;                 

        json\_object &obj = json.to\_object();

        \textcolor{comment}{// prints "1" since the json array holds a "false" bool value in index 2}
        std::cout << obj.at(\textcolor{stringliteral}{"favourite\_values"}).to\_array()[2].is\_bool() << std::endl;   

        \textcolor{comment}{// prints "[2,null,false,\{\}]"}
        std::cout << obj.at(\textcolor{stringliteral}{"favourite\_values"}).dump(0) << std::endl;                  
    \}

    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


\paragraph*{\label{_opening_changing_section}%
Opening, changing and saving a J\+S\+ON file}


\begin{DoxyCode}
\textcolor{comment}{// include library}
\textcolor{preprocessor}{#include "json\_library.h"}

\textcolor{comment}{// for convenience}
\textcolor{keyword}{using namespace }json;

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int}, \textcolor{keywordtype}{char} *[]) \{
    \textcolor{comment}{/*}
\textcolor{comment}{    example assumes "values.json" is a text file that contains the following json object:}
\textcolor{comment}{    \{}
\textcolor{comment}{        "name": "user",}
\textcolor{comment}{        "age": 22,}
\textcolor{comment}{        "favourite\_values": [2, null, false, \{\}]}
\textcolor{comment}{    \}}
\textcolor{comment}{    */}
    json\_document doc(\textcolor{stringliteral}{"values.json"});

    \textcolor{comment}{// only successfull if document contains valid json syntax and the file was found}
    \textcolor{keywordflow}{if} (doc.open()) \{ 
        std::cout << doc.json() << std::endl;
        \textcolor{comment}{/*}
\textcolor{comment}{        prints:}
\textcolor{comment}{        \{}
\textcolor{comment}{            "age": 22,}
\textcolor{comment}{            "favourite\_values": [}
\textcolor{comment}{                2,}
\textcolor{comment}{                null,}
\textcolor{comment}{                false,}
\textcolor{comment}{                \{}
\textcolor{comment}{}
\textcolor{comment}{                \}}
\textcolor{comment}{            ],}
\textcolor{comment}{            "name": "user"}
\textcolor{comment}{        \}}
\textcolor{comment}{        */}

        \textcolor{comment}{// add a new subvalue in "favourite\_values" and change the "age":}

        \textcolor{comment}{// note that the reference symbol is important if }
        \textcolor{comment}{// you want to change the document source.}
        json\_variant &var = doc.json();
        json\_object &obj = var.to\_object();
        obj.at(\textcolor{stringliteral}{"age"}) = 44;
        json\_array &arr = obj[\textcolor{stringliteral}{"favourite\_values"}].to\_array();
        json\_object &obj2 = arr[3].to\_object();
        obj2.insert(\{\textcolor{stringliteral}{"favourite sub value"}, -11\});

        std::cout << doc.json() << std::endl;
        \textcolor{comment}{/*}
\textcolor{comment}{        prints:}
\textcolor{comment}{        \{}
\textcolor{comment}{            "age": 44,}
\textcolor{comment}{            "favourite\_values": [}
\textcolor{comment}{                2,}
\textcolor{comment}{                null,}
\textcolor{comment}{                false,}
\textcolor{comment}{                \{}
\textcolor{comment}{                    "favourite sub value": -11}
\textcolor{comment}{                \}}
\textcolor{comment}{            ],}
\textcolor{comment}{            "name": "user"}
\textcolor{comment}{        \}}
\textcolor{comment}{        */}

        \textcolor{comment}{// only successfull if document only contains valid json\_variants}
        \textcolor{comment}{// (variants with values) and the filename is valid}
        \textcolor{keywordflow}{if} (doc.save()) \{ 
            std::cout << \textcolor{stringliteral}{"document saved!"} << std::endl;

            doc.close(); \textcolor{comment}{// optional}
        \}
    \}

    \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


\paragraph*{\label{_working_with_simple_section}%
Working with simple json\+\_\+variant values}


\begin{DoxyCode}
\textcolor{comment}{// the json variant currently holds no value and is invalid}
json\_variant var;

\textcolor{comment}{// will print "1"}
std::cout << var.is\_invalid\_json() << std::endl;    

\textcolor{comment}{// setting the json\_variant to null}
var = json\_variant::null;
\textcolor{comment}{// NOTE: to initalize a json\_variant with null you }
\textcolor{comment}{// have to use json\_variant::null, using for expample }
\textcolor{comment}{// nullptr will NOT WORK.}

\textcolor{comment}{// will print "0"}
std::cout << var.is\_invalid\_json() << std::endl;

\textcolor{comment}{// will print "1"}
std::cout << var.is\_null() << std::endl;

\textcolor{comment}{// setting the json\_variant to json\_int}
var = 234;

\textcolor{comment}{// setting the json\_variant to double}
var = 0.345;

\textcolor{comment}{// setting the json\_variant to double in scientific notation}
var = 2E-2;

\textcolor{comment}{// setting the json\_variant to bool}
var = \textcolor{keyword}{true};

\textcolor{comment}{// setting the json\_variant to std::string}
var = \textcolor{stringliteral}{"string value"};       
\end{DoxyCode}


\paragraph*{\label{_working_with_json_array_section}%
Working with json\+\_\+array}

Keep in mind that a {\ttfamily json\+\_\+array} is just a {\ttfamily typedef} for {\ttfamily std\+::vector$<$json\+\_\+variant$>$} so all {\ttfamily std\+::vector} functions work on {\ttfamily json\+\_\+array} as well.


\begin{DoxyCode}
\textcolor{comment}{// the json variant currently holds no value and is invalid}
json\_variant var;

\textcolor{comment}{// setting the json\_variant to json\_array}
var = json\_array();
\textcolor{comment}{// the json\_array holds json\_variants so this is valid syntax}
var = json\_array(\{234, 0.345, \textcolor{stringliteral}{"string value"}\});

\textcolor{comment}{// add array values:}

\textcolor{comment}{// add json\_variant element "new value"}
var.to\_array().push\_back(\textcolor{stringliteral}{"new value"});
\textcolor{comment}{// adds json\_variant element "false"}
var.to\_array().push\_back(\textcolor{keyword}{false});                

\textcolor{comment}{// overwrites "string value" with "string value 2"}
var.to\_array()[2] = \textcolor{stringliteral}{"string value 2"};           

\textcolor{comment}{// using a array reference:}

\textcolor{comment}{// The reference symbol is important, otherwise }
\textcolor{comment}{// you'll get a copy and won't modify the source array}
json\_array &arr = var.to\_array();

\textcolor{comment}{// add json\_variant element "456"}
arr.push\_back(456);
 \textcolor{comment}{// overwrites "234" with "567"}
arr[0] = 567;     
\end{DoxyCode}


\paragraph*{\label{_working_with_json_object_section}%
Working with json\+\_\+object}

Keep in mind that a {\ttfamily json\+\_\+object} is just a {\ttfamily typedef} for {\ttfamily std\+::map$<$std\+::string, json\+\_\+variant$>$} so all {\ttfamily std\+::map} functions work on {\ttfamily json\+\_\+object} as well.


\begin{DoxyCode}
\textcolor{comment}{// the json variant currently holds no value and is invalid}
json\_variant var; 

\textcolor{comment}{// initalizing with empty json object}
var = json\_object();
\textcolor{comment}{// using the c++ 11 way to initialize}
var = json\_object(\{ \{\textcolor{stringliteral}{"property 1"}, \textcolor{keyword}{true} \}, \{ \textcolor{stringliteral}{"property 2"}, json\_array(\{1, 2\}) \} \}); 

\textcolor{comment}{// adding new properties with std::pair}
var.to\_object().insert(std::pair<std::string, json\_variant>(\textcolor{stringliteral}{"new property 3"}, -2 ));

\textcolor{comment}{// prints "-2"}
std::cout << var.to\_object().at(\textcolor{stringliteral}{"new property 3"}).to\_int() << std::endl; 

\textcolor{comment}{// adding new properties with c++ 11}
var.to\_object().insert(\{\textcolor{stringliteral}{"new property"}, \textcolor{stringliteral}{"new value"}\});
var.to\_object().insert(\{\textcolor{stringliteral}{"new property 2"}, json\_variant::null \});

\textcolor{comment}{// changing a value}
var.to\_object().at(\textcolor{stringliteral}{"property 1"}) = \textcolor{keyword}{false};

\textcolor{comment}{// prints "0" (false)}
std::cout << var.to\_object().at(\textcolor{stringliteral}{"property 1"}).to\_bool() << std::endl; 

\textcolor{comment}{// using a object reference}
json\_object &obj = var.to\_object();
obj.at(\textcolor{stringliteral}{"property 2"}) = 100;
obj.insert(\{\textcolor{stringliteral}{"property 5"}, -100\});
\end{DoxyCode}


\paragraph*{\label{_typecast_exceptions_section}%
Typecast exceptions}

Everytime a {\ttfamily json\+\_\+variant\+::to\+\_\+$\ast$type$\ast$()} ({\ttfamily to\+\_\+int()}, {\ttfamily to\+\_\+string()}, ...) gets called the json\+\_\+variant will try to cast the underlying value to the requested value. If the actuall value isn\textquotesingle{}t the requested value a {\ttfamily std\+::runtime\+\_\+error} will be thrown. To avoid handling exceptions you have to check whether the underlying value is actually the requested type. You can do so by using {\ttfamily is\+\_\+$\ast$type$\ast$()} ({\ttfamily is\+\_\+int()}, {\ttfamily is\+\_\+string()}, ...)

\subparagraph*{\label{_handling_typecast_expception_section}%
Handling typecast a exception}


\begin{DoxyCode}
json\_variant var = 234;

\textcolor{keywordflow}{try} \{
    \textcolor{comment}{// won't work since var is int}
    \textcolor{keywordtype}{double} d = var.to\_double();  
    \textcolor{comment}{// ...}
\}
\textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::runtime\_error &e) \{
    std::cout << \textcolor{stringliteral}{"runtime\_error: "} << e.what() << std::endl;   
\} 
\end{DoxyCode}


\subparagraph*{\label{_avoid_typecast_exception_section}%
Avoid typecast a exception}


\begin{DoxyCode}
json\_variant var = 234;

\textcolor{comment}{// returns false}
\textcolor{keywordflow}{if} (var.is\_double()) \{
    \textcolor{keywordtype}{double} d = var.to\_double();   
    \textcolor{comment}{// ...}
\}
\textcolor{keywordflow}{else} \{
    std::cout << \textcolor{stringliteral}{"var is not double"} << std::endl;   
\}
\end{DoxyCode}


\paragraph*{\label{_json_and_string_escapes_section}%
J\+S\+ON and string escapes}

All strings in a {\ttfamily json\+\_\+variant} and its children will be unicode escaped before being converted to a string (for example when calling {\ttfamily json\+\_\+variant\+::dump()}). However only the characters " and \textbackslash{} will be escaped since those are the only illegal characters in a J\+S\+ON string. json\+\_\+variant\+::unescape\+\_\+string() is able unescape A\+S\+C\+I\+I-\/characters (other escaped characters will stay escaped).


\begin{DoxyCode}
json\_variant var = R\textcolor{stringliteral}{"(raw json string \(\backslash\)u3093with \(\backslash\)" very \(\backslash\) }
\textcolor{stringliteral}{                      illegal / \(\backslash\)\(\backslash\) \(\backslash\)t "" characters")";}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{std::string escaped = R}\textcolor{stringliteral}{"("raw json string \(\backslash\)u005cu3093with \(\backslash\)u005c\(\backslash\)u0022 very }
\textcolor{stringliteral}{                          \(\backslash\)u005c illegal / \(\backslash\)u005c\(\backslash\)u005c \(\backslash\)u005ct \(\backslash\)u0022\(\backslash\)u0022 }
\textcolor{stringliteral}{                          characters\(\backslash\)u0022")";}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{std::cout << var << std::endl;}
\textcolor{stringliteral}{}\textcolor{comment}{// prints: "raw json string \(\backslash\)u005cu3093with \(\backslash\)u005c\(\backslash\)u0022 very \(\backslash\)u005c illegal }
\textcolor{comment}{//          / \(\backslash\)u005c\(\backslash\)u005c \(\backslash\)u005ct \(\backslash\)u0022\(\backslash\)u0022 characters\(\backslash\)u0022"}

std::cout << json\_variant::unescape\_string(escaped) << std::endl;
\textcolor{comment}{// prints: "raw json string \(\backslash\)u3093with \(\backslash\)" very \(\backslash\) illegal / \(\backslash\)\(\backslash\) \(\backslash\)t "" characters""}
\end{DoxyCode}


\subsubsection*{\label{_customization_section}%
Customization}

The behaviour of the library can be changed by changing defines in the header. The header will be either called \href{https://github.com/n0dex/cppjsonlib/blob/master/json_library.h}{\tt json\+\_\+library.\+h} or \href{https://github.com/n0dex/cppjsonlib/blob/master/json_library_source/json_defines.h}{\tt json\+\_\+library/json\+\_\+defines.\+h} if you\textquotesingle{}ve added the complete directory.


\begin{DoxyItemize}
\item Defining {\ttfamily J\+S\+O\+N\+L\+I\+B\+\_\+\+V\+E\+R\+B\+O\+S\+E\+\_\+\+D\+E\+B\+UG} will enable writing debug messagess into {\ttfamily std\+::cout} and {\ttfamily std\+::cerr} that may be helpfull to you, but those messages mostly report internal library errors.
\item Changing the datatype in {\ttfamily J\+S\+O\+N\+L\+I\+B\+\_\+\+I\+N\+T\+\_\+\+T\+Y\+PE} is possible and may be helpfull if you for expample already know that youre only working with short ints and want to reduce the memory usage. The datatype must be a {\itshape signed} int.
\end{DoxyItemize}

\subsubsection*{\label{_troubleshooting_section}%
Troubleshooting}


\begin{DoxyItemize}
\item The libraries standard namespace is called {\ttfamily json}. If there are conflicting naming issues in your project you can change the namespace by changing the define {\ttfamily J\+S\+O\+N\+L\+I\+B\+\_\+\+N\+A\+M\+E\+S\+P\+A\+CE} in the header (where to find the header is explained in \href{#customization_section}{\tt Customization}). 
\end{DoxyItemize}